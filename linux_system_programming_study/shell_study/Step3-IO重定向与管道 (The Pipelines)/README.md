### 第三阶段：I/O 重定向与管道 (The Pipelines)

恭喜你进入第三阶段！在 LFS 编译过程中，屏幕上会疯狂滚动成千上万行代码编译信息。

  * 如果我们想回头看哪里报错了，屏幕早就滚过去了。
  * 有些工具输出的“错误信息”其实不需要理会。
  * 我们需要把这些信息**抓取**下来保存到文件里。

这就是 **I/O 重定向** 的作用。

#### 1\. 三大“流” (Streams)

Linux 系统中，每个进程启动时都会打开三个文件描述符：

| 描述符 | 名称 | 缩写 | 用途 | 默认去向 |
| :--- | :--- | :--- | :--- | :--- |
| **0** | 标准输入 | `stdin` | 程序读取数据的地方 | 键盘 |
| **1** | 标准输出 | `stdout` | 程序打印正常结果的地方 | 屏幕终端 |
| **2** | 标准错误 | `stderr` | 程序打印报错信息的地方 | 屏幕终端 |

#### 2\. 重定向符号 (核心语法)

| 符号 | 作用 | LFS 场景 |
| :--- | :--- | :--- |
| `>` | **覆盖**输出到文件 | 生成新的配置文件：`echo "nameserver 8.8.8.8" > /etc/resolv.conf` |
| `>>` | **追加**输出到文件 | 添加日志：`echo "编译完成" >> build.log` |
| `2>` | 只重定向**错误**信息 | 忽略错误：`rm file_not_exist 2> /dev/null` |
| `2>&1` | **错误和正常输出合并** | 编译软件：`make > make.log 2>&1` (最常用！) |

> **关键解释 `2>&1`**：
> 它的意思是：“把**通道 2**（错误）接到**通道 1**（正常输出）上去”。这样所有的信息都会顺着通道 1 流入文件中。

#### 3\. 管道 `|`

管道的作用是：**把上一个命令的输出 (`stdout`)，直接插到下一个命令的输入 (`stdin`) 嘴里。**

  * **例子**：`cat /etc/passwd | grep "root"`
      * `cat` 吐出文件内容 -\> `grep` 接收并过滤包含 "root" 的行。

-----

### 🛠️ 任务三：模拟 LFS 编译日志系统

为了练习重定向，我们不真的编译软件，而是写一个脚本模拟编译过程中的日志记录。

编写脚本 `log_test.sh`，需求如下：

1.  **定义变量**：`LOG_FILE="build.log"`。
2.  **清理旧日志**：
      * 检查 `${LOG_FILE}` 是否存在，如果存在，先删除它（确保每次运行都是新的）。
3.  **模拟正常编译**：
      * 使用 `echo` 输出 "正在配置源码..."，并将这句话**写入**（覆盖）到日志文件中（不要显示在屏幕上）。
      * 使用 `echo` 输出 "正在编译核心模块..."，并将这句话**追加**到日志文件中。
4.  **模拟报错（难点）**：
      * 我们要故意制造一个错误。尝试列出一个不存在的文件，例如 `ls /bu_cun_zai_de_wen_jian`。
      * **关键要求**：即使是报错信息，也不能显示在屏幕上，必须**追加**保存到 `${LOG_FILE}` 中。
      * *(提示：你需要用到 `>>` 和 `2>&1`，或者分别重定向)*
5.  **验证**：
      * 脚本运行结束后，屏幕上应该**什么都不显示**（静默运行）。
      * 脚本最后一行使用 `cat ${LOG_FILE}` 把日志文件的内容打印出来，证明刚才的操作都记录成功了。

**这个任务有点绕，主要考察你对 `>`、`>>` 和 `2>&1` 的组合使用。期待你的代码！**