### 第二阶段：流程控制与逻辑判断 (The Logic)

在 LFS 构建过程中，我们经常面临这样的场景：

  * *“如果 `/mnt/lfs` 目录不存在，我就创建它。”*
  * *“如果当前用户不是 root，就报错退出，因为普通用户没权限挂载硬盘。”*
  * *“如果编译失败了，就不要继续执行安装命令。”*

这都需要**逻辑判断**。

#### 1\. 退出状态码 (Exit Status) —— 判断成败的金标准

在 Shell 中，怎么知道上一条命令是成功了还是失败了？
我们使用特殊变量 **`$?`**。

  * **`0`**：表示**成功** (Success)。
  * **非 0** (1-255)：表示**失败** (Failure)。

**在终端试一下：**

```bash
ls /tmp        # 这是一个存在的目录
echo $?        # 输出 0

ls /bu_cun_zai # 这是一个不存在的目录
echo $?        # 输出 2 (或其他非0数字)
```

> **LFS 关键点**：我们在写自动化脚本时，每执行完一个关键步骤（比如 `make`），都要检查 `$?` 是否为 0。

#### 2\. Test 命令与 If 结构

Shell 里的 `if` 语法稍微有点怪，它依赖于 `test` 命令（通常简写为方括号 `[ ]`）。

**基本语法：**

```bash
if [ 条件测试 ]; then
    # 条件成立时执行
else
    # 条件不成立时执行
fi
```

**⚠️ 注意：** 方括号 `[` 和 `]` 的**内部两侧必须有空格**！
**⚠️ 注意：** Bash 中 数值比较必须用空格分隔运算符，否则会被当作字符串拼接处理
  * ❌ `if [$a=1];` (语法错误)
  * ✅ `if [ "$a" = "1" ];` (正确)


#### 3\. 常用的测试参数 (LFS 高频版)

| 参数 | 含义 | 示例 |
| :--- | :--- | :--- |
| **`-d`** | directory，判断目录是否存在 | `[ -d "$LFS" ]` |
| **`-f`** | file，判断普通文件是否存在 | `[ -f "$LFS/sources/wget-list" ]` |
| **`-z`** | zero，判断字符串是否为空 | `[ -z "$LFS" ]` (如果没定义LFS变量，返回真) |
| **`!`** | 逻辑非 (取反) | `[ ! -d "$LFS" ]` (如果目录**不**存在) |

-----

这是一个非常深刻且非常棒的问题！你不仅在写代码，而且在思考 Shell 解释器底层是如何工作的。

你的困惑在于：**你以为 `if` 判断的是“方括号里的东西是不是空的/真的”**，但实际上 Shell 的 `if` 并不直接看方括号里的内容，而是看 **`[` 这个命令运行完后的“退出状态码”**。

让我们拆解一下为什么 `[ $?=0 ]` 是错的，而 `[ $? -eq 0 ]` 是对的。

---

### 核心解密：`[` 实际上是一个程序

在 Linux 中，`[` 并不是 `if` 语法的一部分，它实际上是一个叫 `/usr/bin/test` 的**可执行程序**（或者 Bash 内置命令）。

当你写 `if [ ... ]; then` 时，Shell 其实是在运行一个命令。

#### 场景一：你写的 `[ $?=0 ]` （错误的）

假设 `$?` 的值是 `0`（mkdir 成功了）。

1.  **变量替换**：Shell 先把 `$?` 换成 `0`。
2.  **命令构建**：命令变成了 `[ 0=0 ]`。
3.  **参数传递**：Shell 传递给 `[` 命令的**参数只有一个**，就是字符串 `"0=0"`。
    * 这里没有空格，所以系统认为这是一个整体。
4.  **`[` 的内部逻辑**：
    * `[` 程序收到**一个参数**时，它的默认行为是：**“检查这个字符串是不是空字符串？”**
    * 字符串 `"0=0"` 是空的吗？不是。
    * **结论**：不为空 -> 真 -> `[` 命令返回退出码 **0** (代表成功)。
5.  **反转测试**：假设 `$?` 是 `1`（mkdir 失败了）。
    * 命令变成 `[ 1=0 ]`。
    * 参数还是**一个字符串** `"1=0"`。
    * 字符串 `"1=0"` 是空的吗？不是。
    * **结论**：不为空 -> 真 -> `[` 命令依然返回退出码 **0** (代表成功)。
    * **结果**：无论成功失败，永远显示“创建成功”。

---

#### 场景二：你修改后的 `[ $? -eq 0 ]` （正确的）

假设 `$?` 的值是 `1`（mkdir 失败了）。

1.  **变量替换**：Shell 把 `$?` 换成 `1`。
2.  **命令构建**：命令变成了 `[ 1 -eq 0 ]`。
3.  **参数传递**：因为有**空格**，Shell 传递给 `[` 命令的参数是**三个**：
    * 参数1: `"1"`
    * 参数2: `"-eq"`
    * 参数3: `"0"`
4.  **`[` 的内部逻辑**：
    * `[` 程序收到**三个参数**，且中间是 `-eq` 时，它的行为切换模式：**“执行数值比较逻辑”**。
    * 它计算：数值 1 等于 数值 0 吗？
    * 答案：不等于。
    * **结论**：逻辑为假 -> `[` 命令返回退出码 **1** (代表失败)。
5.  **If 的判断**：
    * `if` 看到 `[` 命令返回了 **1**，就知道条件不成立，于是走 `else` 分支。

---

### 🛠️ 任务二：编写环境检查与创建脚本

我们来编写一个稍微复杂一点的脚本 `mount_check.sh`，模拟 LFS 的准备工作。

**需求如下：**

1.  **定义变量**：`LFS=/mnt/lfs` (或者你 WSL 里想用的其他测试路径，比如 `~/lfs_test` 也可以)。
2.  **Root 用户检查**：
      * Shell 中当前用户的 ID 保存在变量 `$UID` 中，Root 的 UID 永远是 `0`。
      * **逻辑**：如果 `$UID` 不等于 `0`，则输出“请使用 root 权限运行此脚本（提示：sudo）”，并使用 `exit 1` 退出脚本。
      * *提示：数字比较使用 `-ne` (not equal) 或者 `!=`。*
3.  **目录检查与创建**：
      * **逻辑**：检查 `${LFS}` 目录是否存在。
      * **如果存在**：输出“目录 ${LFS} 已存在，准备就绪。”
      * **如果不存在**：输出“目录不存在，正在创建 ${LFS} ...”，然后执行 `mkdir -p ${LFS}` 创建它。
4.  **二次确认**：
      * 创建命令执行后，再次检查 `$?`。如果为 0，输出“创建成功”；否则输出“创建失败”。

**编写并运行这个脚本。**
*(注：因为涉及 root 权限检查，运行脚本时你可能需要用 `sudo ./mount_check.sh`，或者看看如果不加 sudo 会发生什么)*

请贴出你的代码和两次运行结果（一次不加 sudo，一次加 sudo）。