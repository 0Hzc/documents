
### 第五阶段：函数、循环与健壮性 (Robustness)

恭喜你进入了基础语法的最后一个阶段！🚀

在构建 LFS 时，我们面临一个巨大的挑战：**重复**。
我们需要对几十个软件包重复执行几乎相同的步骤：解压 -\> 进入目录 -\> `configure` -\> `make` -\> `make install` -\> 退出目录 -\> 删除源码。

如果我们把这些步骤复制粘贴几十次，脚本会变得又臭又长，而且一旦要把 `make` 改成 `make -j4`，你得改几十个地方。

**解决方案：函数 (Functions)**

#### 1\. 函数的基础语法

函数就是把一段代码“打包”，给它起个名字，随时调用。

```bash
# 定义函数
build_package() {
    echo "正在构建软件包..."
    # 具体的构建命令
}

# 调用函数 (直接写名字，不需要加括号)
build_package
```

#### 2\. 给函数传参 (重点)

Shell 函数的传参方式和脚本传参一模一样，使用 `$1`, `$2` 等位置变量。

**⚠️ 关键注意：** 函数内部的 `$1` 是**函数参数**，脚本最外层的 `$1` 是**脚本参数**，它们是互相独立的！

```bash
compile() {
    # 这里的 $1 是调用 compile 时传进来的第一个参数
    echo "正在编译软件：$1"
}

compile "Binutils"  # 输出：正在编译软件：Binutils
compile "GCC"       # 输出：正在编译软件：GCC
```
#### 3. 变量的作用域 (Scope) —— `local` 的重要性

默认情况下，Shell 中的变量全是**全局变量**。这意味着，如果你在函数内部修改了一个变量，函数外部的同名变量也会被修改！这在大型脚本中非常危险。

**最佳实践：** 在函数内部定义的变量，一定要加上 `local` 关键字。

```bash
my_var="Global"

test_scope() {
    local my_var="Local"  # 加上 local，互不干扰
    echo "函数内部: $my_var"
}

test_scope
echo "函数外部: $my_var"
```

#### 4. 函数的返回值

Shell 函数的返回值机制和其他语言（如 Python, C）完全不同，初学者很容易混淆。

*   **`return` 关键字**：只能返回 **0-255** 的整数，通常用于表示**状态**（0表示成功，非0表示失败）。可以通过 `$?` 获取。
*   **获取计算结果**：如果你想让函数返回一个字符串或数字结果，应该使用 `echo` 输出，然后在调用时用 `$()` 捕获。

```bash
# 错误写法：试图 return 字符串
get_version() {
    return "1.0.0"  # ❌ 报错！只能是数字
}

# 正确写法：echo 输出，外部捕获
get_version() {
    echo "1.0.0"
}

ver=$(get_version)
echo "当前版本: $ver"
```

#### 5. 脚本的“防弹衣”：调试与健壮性

在 LFS 构建中，如果第 5 步出错了，脚本却继续跑到了第 50 步，那简直是灾难。我们需要让脚本足够“敏感”和“健壮”。

**常用配置 (建议写在脚本开头)：**

*   **`set -e` (Exit on Error)**: 只要有一行命令报错（返回非0状态码），脚本立即停止执行。
    *   *注意：如果命令在 `if` 条件中，或者用 `||` 连接，不会触发退出。*
*   **`set -u` (Unset Variables)**: 如果使用了未定义的变量，脚本报错并退出。防止手滑写错变量名（如 `$RM_RF /` 这种恐怖事故）。
*   **`set -o pipefail`**: 默认情况下，管道命令 `cmd1 | cmd2` 的返回值取决于最后一个命令。如果 `cmd1` 失败但 `cmd2` 成功，脚本会以为整体成功。开启此选项后，只要管道中有一个命令失败，整个管道就视为失败。
*   **`set -x` (X-trace)**: 调试神器。它会把脚本执行的每一行命令都打印到屏幕上（带 `+` 号前缀），让你知道脚本到底在干嘛。

```bash
#!/bin/bash
set -e
set -u
set -o pipefail
```

-----

### 🛠️ 任务七：封装一个“LFS 构建函数”

我们将模拟 LFS 中最经典的构建流程。请编写脚本 `function_test.sh`。

**需求如下：**

1.  **定义函数**：创建一个名为 `mock_build` 的函数。
2.  **函数逻辑**：
      * 该函数接收**一个参数**（软件包的名字，如 "nano"）。
      * 进入函数后，输出 `"=== 开始构建 $1 ==="`。
      * 模拟睡眠 1 秒 (`sleep 1`)，代表正在编译。
      * 输出 `"$1 安装完成！"`。
3.  **主程序调用**：
      * 在函数定义之外（脚本底部），连续调用三次这个函数，分别传入：
          * `"Binutils"`
          * `"GCC"`
          * `"Glibc"`
4.  **执行效果**：
      * 你应该能看到屏幕上每隔一秒蹦出一条安装成功的消息。

**这是将脚本从“流水账”升级为“模块化程序”的关键一步。请展示你的代码！**