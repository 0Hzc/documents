
### 1\. 脚本的骨架 (The Skeleton)

任何 Shell 脚本的第一行都至关重要，它被称为 **Shebang**。

#### 核心语法

```bash
#!/bin/bash
```

  * `#!`：告诉系统这个文件不是普通文本，而是一个可执行脚本。
  * `/bin/bash`：告诉系统使用哪个解释器来运行后面的代码（LFS 强烈依赖 Bash，而不是 sh 或 zsh）。

#### 动手操作

打开你的终端，我们创建一个名为 `lfs_env.sh` 的文件：

1.  使用编辑器（推荐 `nano` 或 `vim`，新手建议 `nano`）：
    ```bash
    nano lfs_env.sh
    ```
2.  输入以下内容：
    ```bash
    #!/bin/bash
    # 这是一个注释，Shell 会忽略它
    echo "正在配置 LFS 环境..."
    ```
3.  保存退出（Nano 操作：`Ctrl+O` 保存 -\> 回车 -\> `Ctrl+X` 退出）。

#### 赋予权限与执行

在 Linux 中，新建的文件通常没有执行权限。

  * **赋予权限：** `chmod +x lfs_env.sh` (+x 代表 executable，可执行)。
  * **运行脚本：** `./lfs_env.sh` (这里的 `./` 表示“在当前目录下查找”，出于安全考虑，Linux 默认不搜索当前目录)。

-----

### 2\. 变量：LFS 的基石

在 LFS 手册中，你会在一开始看到类似 `export LFS=/mnt/lfs` 的命令。Shell 变量有几个必须遵守的死板规则。

#### 赋值规则 (严禁空格！)

  * **错误：** `LFS = /mnt/lfs` (Shell 会把 `LFS` 当作命令，`=` 当作参数)。
  * **正确：** `LFS=/mnt/lfs` (等号两边**不能**有空格)。

#### 引用变量

要使用变量的值，需要在前面加 `$`。

  * `echo $LFS`
  * `echo ${LFS}` (推荐) —— **这是最佳实践**。

> **为什么推荐 `${VAR}`？**
> 假设你想输出 `/mnt/lfs/tools`。
>
>   * `echo $LFS/tools` -\> 正常。
>   * 假设变量名是 `LFS_VER`，你想输出版本号加下划线：`echo $LFS_VER_info` -\> Shell 会去寻找名为 `LFS_VER_info` 的变量（找不到），而不是 `LFS_VER`。
>   * `echo ${LFS_VER}_info` -\> 明确告诉 Shell 变量名在哪里结束。

-----

### 3\. 单引号 vs 双引号 (重难点)

这是 LFS 构建脚本中最容易导致“诡异失败”的地方。

  * **双引号 `"` (弱引用)：** 允许变量替换。Shell 会解析里面的 `$`。
  * **单引号 `'` (强引用)：** **所见即所得**。里面写什么就是什么，Shell 完全不干预。

#### 演示

请在你的 `lfs_env.sh` 中追加以下代码来观察区别：

```bash
LFS="/mnt/lfs"

# 双引号：解析变量
echo "构建路径是：${LFS}/tools"
# 输出：构建路径是：/mnt/lfs/tools

# 单引号：原样输出
echo '构建路径是：${LFS}/tools'
# 输出：构建路径是：${LFS}/tools
```

> **LFS 实战场景：**
> 当我们后面用 `sed` 修改配置文件时，如果你想让 `sed` 插入一个字面量的 `$`, 你必须用单引号；如果你想把脚本里的路径变量插入文件，你必须用双引号。

-----

### 4\. 环境变量与 export

在脚本中定义的变量通常只在**当前脚本**内有效。如果你希望这个变量在脚本运行的子进程（比如脚本里调用的 `make` 命令）中也能看到，必须使用 `export`。

```bash
MY_VAR="local"
export LFS="/mnt/lfs" # 这个变量会被传递给子进程
```

-----

### 🛠️ 任务一：编写你的第一个 LFS 准备脚本

为了验证你掌握了以上内容，请在 WSL 中编写一个名为 `setup_check.sh` 的脚本，完成以下需求：

1.  **Shebang**：指定 bash。
2.  **定义变量**：
      * 定义变量 `LFS`，值为 `/mnt/lfs`。
      * 定义变量 `LFS_TGT`，值为 `x86_64-lfs-linux-gnu`。
      * 定义变量 `JOB_COUNT`，值为 `4` (模拟 4 核编译)。
3.  **输出信息**：
      * 请使用 **双引号** 输出这句话：`我们将构建目标：x86_64-lfs-linux-gnu，挂载点为：/mnt/lfs` (必须使用上面定义的变量)。
      * 请使用 **单引号** 输出这句话（为了提醒用户不要弄错变量名）：`请确保系统变量 ${LFS} 已正确设置。`
      * 最后输出：`编译并将使用 4 个核心。` (使用变量)。
4.  保存并赋予执行权限，然后运行它。

**请把你写好的脚本代码贴出来（或者运行的截图/结果），我们来看看是否符合标准。之后我们将进入流程控制环节！**