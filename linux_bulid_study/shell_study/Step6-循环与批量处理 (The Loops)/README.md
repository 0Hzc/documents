### 第六阶段：循环与批量处理 (The Loops)

我们来看看如何让计算机帮我们“重复劳动”。

#### 1\. For 循环 —— LFS 的流水线

在 LFS 自动化中，我们通常会把所有要安装的软件名字放在一个列表里（或者一个文件里），然后让脚本挨个处理。

**基本语法：**

```bash
# 语法一：直接遍历字符串列表
for package in "Binutils" "GCC" "Glibc"; do
    echo "正在处理：$package"
    # 这里调用你的构建函数
done
```

#### 2\. 结合函数使用

这才是脚本的终极形态。我们将刚才的 `mock_build` 函数和 `for` 循环结合起来。

-----

### 🛠️ 任务八：最终考核 —— 批量构建模拟器

我们将编写一个名为 `lfs_automation.sh` 的脚本，它将是你这一系列学习成果的**集大成者**。

**需求如下：**

1.  **设置严格模式（新知识点）**：
      * 在脚本第二行（Shebang 之后），加上 `set -e`。
      * **作用**：告诉 Shell，只要脚本里有**任何**一条命令报错（返回非 0），立刻退出脚本，不要往下跑了。这是 LFS 脚本的“安全带”。
2.  **定义变量**：
      * `LFS_MNT="/mnt/lfs_sim"` (模拟挂载点)。
3.  **定义函数**：
      * 复制之前的 `mock_build` 函数过来。
      * **升级函数**：在函数内部，在 `sleep 1` 之后，加一行判断：
          * `if [ "$1" = "Glibc" ]; then ... fi`
          * **制造故障**：如果当前包名是 "Glibc"，则执行一个不存在的命令（例如 `non_existent_command`），故意触发报错。
4.  **主逻辑 (For 循环)**：
      * 定义一个列表：包含 `"Binutils"`, `"GCC"`, `"Glibc"`, `"Bison"`。
      * 使用 `for` 循环遍历这个列表。
      * 在循环内部，调用 `mock_build` 函数。
5.  **预期结果**：
      * 脚本应该顺利安装 Binutils 和 GCC。
      * 当轮到 Glibc 时，因为触发了错误命令，且我们开启了 `set -e`，**脚本应该直接报错退出**。
      * **关键点**：最后的 "Bison" 应该**永远不会**被执行。

**请编写并运行这个脚本。如果能看到它在 Glibc 处戛然而止，恭喜你，你已经掌握了编写 LFS 自动化脚本的核心逻辑！**