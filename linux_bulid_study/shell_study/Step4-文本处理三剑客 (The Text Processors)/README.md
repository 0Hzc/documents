### 第四阶段：文本处理三剑客 (The Text Processors)

LFS 的构建过程，本质上就是把源码包下载下来，修改一下配置（改掉写死的路径、修复 Bug），然后编译。

因为我们不能手动打开记事本去改几千个文件，所以我们需要 **“外科手术刀”** —— **Sed**。

#### 1. Sed (Stream Editor) —— 核心中的核心

在 LFS 手册中，你几乎会在每一章都看到 `sed`。它的作用是：**不打开文件，直接修改文件内容。**

**基本语法：**

```bash
sed -i 's/旧内容/新内容/g' 文件名
```

*   **`-i` (in-place)**: **这是最关键的参数之一**。
    *   默认情况下，`sed` 只会将处理后的结果打印到屏幕上，**不会修改原文件**。
    *   加上 `-i` 后，`sed` 会**直接修改文件内容**（实际上是创建一个临时文件然后覆盖原文件）。
    *   *小心使用：* 如果你怕改错，可以使用 `-i.bak`，这样它在修改前会先把原文件备份为 `文件名.bak`。
*   **`'...'`**: 单引号括起来的部分是 `sed` 的**脚本/指令**。
*   **`s` (substitute)**: 这是 `sed` 最常用的命令，代表“替换”。
*   **`/`**: 这是**分隔符**。通常用斜杠，但如果你的内容里也有斜杠（比如路径 bin），你可以换成其他符号，比如 `#` 或 `@`（例如 `s#旧#新#g`），这样就不用疯狂转义斜杠了。
*   **`旧内容`**: 你想查找的字符串或**正则表达式**。
*   **`新内容`**: 你想替换成的字符串。
*   **`g` (global)**: **全局替换标志**。
    *   如果不加 `g`，`sed` 默认**只替换每一行中出现的第一个**匹配项。
    *   加上 `g`，它会替换每一行中**所有**出现的匹配项。
*   **`文件名`**: 你要操作的目标文件。

---

#### 2. `sed` 不只有 `-i` 这一个参数

`sed` 非常强大，参数极其丰富。`-i` 只是因为我们要“修改文件”时最常用到它。

以下是几个最常用的其他参数，配合起来威力倍增：

##### 1. `-n` (silent/quiet)

*   **作用**：**静默模式**。默认情况下，`sed` 会把所有读取到的行都打印出来（无论是否被修改）。使用 `-n` 后，它**只打印你明确要求打印的行**。
*   **常用场景**：配合 `p` (print) 命令，只查看特定的行。
*   **例子**：
    ```bash
    # 只打印第 5 行
    sed -n '5p' filename
    # 只打印包含 "error" 的行 (类似 grep)
    sed -n '/error/p' filename
    ```

##### 2. `-e` (expression)

*   **作用**：**多点编辑**。允许你在同一个 `sed` 命令中执行多个脚本/操作。
*   **常用场景**：你想一次性做两件事，比如先删除第一行，再替换某个词。
*   **例子**：
    ```bash
    # 同时执行：1. 删除第1行 (1d)；2. 将 apple 替换为 orange
    sed -e '1d' -e 's/apple/orange/g' filename
    ```

##### 3. `-r` 或 `-E` (extended regex)

*   **作用**：**启用扩展正则表达式**。
*   **常用场景**：默认的 `sed` 使用基础正则表达式，像 `+`, `?`, `|`, `()` 这些符号通常需要加反斜杠转义（如 `\+`）。加上 `-r` (Linux GNU sed) 或 `-E` (macOS/BSD sed) 后，就可以直接使用这些高级正则符号，写起来更清爽。
*   **例子**：
    ```bash
    # 匹配 "go" 或 "goto" (使用 | 需要扩展正则)
    sed -r 's/go|goto/jump/g' filename
    ```

##### 4. `-f` (file)

*   **作用**：**从文件中读取脚本**。
*   **常用场景**：如果你的替换逻辑非常复杂，写在命令行里太乱了，可以把 `s/旧/新/g` 等指令写在一个文件里（比如 `script.sed`），然后让 `sed` 去读它。
*   **例子**：
    ```bash
    sed -f script.sed filename
    ```

#### 3. 分隔符的艺术 (LFS 必考题)

通常我们用 `/` 做分隔符：`s/abc/xyz/g`。
**但是**，如果要修改的是**文件路径**，比如把 `/usr/lib` 改成 `/tools/lib`，用 `/` 就会变成这样：
`s//usr/lib//tools/lib/g` -> **报错！** Shell 会看晕。

**解决方案**：Sed 允许你用**任意字符**当分隔符。在处理路径时，我们通常用 `#` 或 `@`。

```bash
sed -i 's@/usr/lib@/tools/lib@g' filename
```

---

#### 下一步：Grep 与 Awk (信息提取大师)

LFS 的准备阶段有一个著名的脚本叫 `version-check.sh`。它的工作原理是：运行 `gcc --version`，然后从一大堆输出中**精准提取**出版本号（比如 `11.2.0`），以此来判断你的宿主系统是否合规。

仅仅用 `sed` 做替换是不够的，我们需要 **Grep (查找)** 和 **Awk (提取)**。

##### 1. Grep：过滤器

Grep 用于“捞取”你感兴趣的**行**。

*   **基本用法**：`grep "关键字" 文件名`
*   **管道用法**：`cat 文件 | grep "关键字"`
*   **LFS 常用参数**：
    *   `-q` (quiet)：静默模式。不输出任何内容，只通过退出码 `$?` 告诉你是找到了(0) 还是没找到(1)。这在 `if` 判断中极好用。

##### 2. Awk：手术钳 (列提取)

Awk 默认按**空格**把一行切分成很多“列” (Fields)。

*   `$1` 代表第一列，`$2` 代表第二列... `$NF` 代表最后一列。
*   **基本语法**：`echo "one two three" | awk '{print $2}'` -> 输出 `two`

**实战演示：**
假设 `gcc --version` 的输出是：
`gcc (Ubuntu 11.4.0-1ubuntu1) 11.4.0`

我们要提取最后的 `11.4.0`：

```bash
echo "gcc (Ubuntu 11.4.0-1ubuntu1) 11.4.0" | awk '{print $NF}'
```

*(注：`$NF` 是 awk 的内置变量，代表 Last Field 最后一列)*

`awk` 的语法非常灵活，**并不是必须**同时使用 `''` 和 `{}`，这取决于你想做什么。

简单来说，`awk` 的核心语法结构是：

```bash
awk 'pattern { action }' 文件名
```

### 🛠️ 任务五：Sed 手术刀练习

为了模拟 LFS 中修改 `Makefile` 路径的场景，请编写一个脚本 `sed_practice.sh`。

**需求如下：**

1.  **准备素材**：
    *   创建一个名为 `config.mk` 的假配置文件。
    *   内容使用 `cat` 生成（或者 echo），包含一行：`INSTALL_DIR = /usr/local/bin`。
2.  **查看原文件**：使用 `cat` 输出修改前的内容。
3.  **执行手术**：
    *   使用 `sed` 命令，将文件中的 `/usr/local/bin` 修改为 `/tools/bin`。
    *   **要求**：必须使用 `@` 作为分隔符（不要用 `/` 转义）。
    *   **要求**：直接修改文件 (`-i`)。
4.  **验证结果**：
    *   再次使用 `cat` 输出修改后的内容。
    *   如果输出的是 `INSTALL_DIR = /tools/bin`，则手术成功。

**这是 LFS 中最常用的“修改源码”手段，请务必掌握。期待你的代码！**

### 🛠️ 任务六：编写系统版本检测器

我们将模拟 LFS 的宿主环境检查过程。编写脚本 `check_tool.sh`。

**需求如下：**

1.  **模拟数据**：
    *   定义一个变量 `TOOL_INFO="bison (GNU Bison) 3.8.2"`。
    *   (这是模拟 `bison --version` 命令的第一行输出)。
2.  **Grep 检查**：
    *   使用 `if` 和 `grep` (配合管道 `echo $TOOL_INFO | ...`) 检查字符串中是否包含 `"GNU"` 这个词。
    *   **要求**：使用 `-q` 静默模式。
    *   如果包含，输出 `"发现 GNU 工具，继续检查..."`。
    *   如果不包含，输出 `"非 GNU 工具，停止。"` 并退出。
3.  **Awk 提取**：
    *   在确认包含 GNU 后，使用 `awk` 从 `$TOOL_INFO` 中提取出版本号 `3.8.2`。
    *   (观察一下，`3.8.2` 在第几列？或者是不是最后一列？)
    *   将提取出的版本号赋值给一个新变量 `VERSION`。
    *   *(提示：`VERSION=$(echo ... | awk ...)` )*
4.  **最终输出**：
    *   打印：`"检测到 Bison 版本为：${VERSION}"`。

**这个任务模拟了 LFS 手册中 `version-check.sh` 的核心逻辑。请展示你的代码！**


