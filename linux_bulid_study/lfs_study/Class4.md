### 🏛️ 第四课：隔离的艺术 —— LFS 用户与环境配置

在开始写代码之前，我们需要解决一个严肃的问题：**为什么我们不能用 Root 身份去编译？**

#### 1\. 为什么必须创建 `lfs` 用户？

你现在是 WSL 的 `root` 用户（通过 `sudo`）。如果你直接开始编译 GCC 或 Binutils，会有两个巨大风险：

1.  **毁灭宿主的风险**：如果你手滑（比如在 Makefile 里写错了一行 `rm -rf /`），你的 WSL 系统就废了。
2.  **“污染”风险（最关键）**：
      * Root 用户有很多环境变量（`PATH`, `LD_LIBRARY_PATH` 等），指向宿主机的 `/usr/include` 或 `/usr/lib`。
      * 如果在编译时，新的 GCC 偷偷引用了宿主机的库文件，编译可能也会成功。
      * **但是**，当你把做好的 LFS 放到另一台机器上运行时，它会因为找不到原来的宿主文件而报错。这叫“不纯净的构建”。

因此，我们需要创建一个**一穷二白**的新用户——`lfs`。

  * 它没有复杂的环境变量。
  * 它的权限被严格限制。
  * 我们通过编写它的 `.bashrc`，**强行**指定它只能看哪里，不能看哪里。

#### 2\. 关键环境变量解密

我们需要给 `lfs` 用户配置几个雷打不动的变量：

  * **`LFS=/mnt/lfs`**：告诉它工作目录在哪。
  * **`LC_ALL=POSIX`**：
      * 这是为了防止“语言不通”。
      * 如果你用中文环境编译，`grep` 或 `sed` 可能会因为无法识别某些字符而报错，或者按照中文排序规则处理文件列表，导致编译顺序出错。`POSIX` 是计算机最原始的语言环境。
  * **`LFS_TGT=$(uname -m)-lfs-linux-gnu`**：
      * 这是**交叉编译**的核心。
      * 我们在宿主机上，要编译一个给未来 LFS 系统用的工具。我们必须明确告诉编译器：“我是 x86\_64 架构，我是专门为 LFS 打造的 Linux GNU 系统”。
  * **`PATH=/tools/bin:/bin:/usr/bin`**：
      * **注意顺序！** `/tools/bin` 放在最前面。
      * 这意味着：如果我们编译出了一个新的 `gcc` 并放在了 `/tools/bin` 下，系统会**优先使用**这个新的 gcc，而不是宿主机的 `/usr/bin/gcc`。这就是“自举”的开始。


#### 3\. useradd -s /bin/bash -g lfs -m -k /dev/null lfs命令解析

这个 `useradd` 命令的作用是**创建一个名为 `lfs` 的系统用户**，并为其配置一系列特定属性，常见于 Linux From Scratch（LFS）编译构建系统的场景中。下面拆解每个参数的含义，以及整体命令的作用：

##### 命令参数逐行解析
| 参数                | 含义说明                                                                 |
|---------------------|--------------------------------------------------------------------------|
| `useradd`           | Linux 系统创建新用户的核心命令（底层调用 `/etc/passwd` `/etc/group` 等文件） |
| `-s /bin/bash`      | 指定该用户的默认登录 Shell 为 `/bin/bash`（替代默认的 sh 或 dash）         |
| `-g lfs`            | 指定用户的**主组**为 `lfs`（需确保 `lfs` 组已提前创建，否则命令会失败）    |
| `-m`                | 自动创建该用户的家目录（默认路径：`/home/lfs`）                           |
| `-k /dev/null`      | 取消用户家目录的默认模板复制（`/dev/null` 表示空，不复制任何模板文件）     |
| `lfs`               | 要创建的用户名（最终生成的用户名为 `lfs`）                                |

##### 核心作用总结
1. **创建专属用户**：为 LFS 编译过程创建一个独立的 `lfs` 用户（避免使用 root 直接编译带来的权限风险）；
2. **环境隔离**：
   - 指定 bash 作为 Shell，保证编译过程中脚本兼容性；
   - 主组设为 `lfs`，统一文件权限归属；
   - 家目录独立（`/home/lfs`），且不复制系统默认模板（避免冗余配置干扰编译）。

##### 前置条件与补充说明
1. **必须先创建 `lfs` 组**：  
   执行该命令前需先运行 `groupadd lfs`，否则会报错 `group 'lfs' does not exist`；
2. **权限说明**：  
   该命令需要 root 权限执行（普通用户无法创建新用户）；
3. **验证创建结果**：  
   创建后可通过以下命令验证：
   ```bash
   # 查看用户信息
   id lfs
   # 查看家目录
   ls -ld /home/lfs
   # 查看默认 Shell
   grep lfs /etc/passwd  # 输出中最后一列应为 /bin/bash
   ```



-----

### 🛠️ 任务四：创建构建用户与环境配置文件

请编写脚本 `setup_lfs_user.sh`。这个脚本依然需要 `sudo` 运行，因为它涉及创建用户。

**我负责提供配置文件内容，你负责实现自动化逻辑：**

**脚本需求：**

1.  **创建组和用户**：

      * 创建组 `lfs`。
      * 创建用户 `lfs`，属于 `lfs` 组。
      * 参数建议：`useradd -s /bin/bash -g lfs -m -k /dev/null lfs`
      * *解释*：`-k /dev/null` 表示不复制系统的默认骨架文件，我们要一个**绝对干净**的家目录。
      * **设置密码**：脚本里可以使用 `echo "lfs:123456" | chpasswd` 来自动设置密码（或者你手动设）。

2.  **移交目录权限**：

      * 我们在第二课创建了 `/tools` 软链接和 `/mnt/lfs/tools` 目录。
      * 现在，必须把这两个地方的所有权（Owner）交给 `lfs` 用户，否则它没法往里面装软件。
      * 命令：`chown -v lfs:lfs $LFS/tools` 和 `chown -v lfs:lfs $LFS/sources`。

3.  **生成配置文件 (核心)**：

      * 在 `/home/lfs` 目录下，生成 `.bash_profile` 和 `.bashrc`。
      * **注意**：因为你是用 root 运行脚本，生成文件的属主默认是 root。生成完后，记得把这俩文件的属主也改为 `lfs`。

**配置文件内容（请原样写入）：**

**`.bash_profile` 内容：**

```bash
exec env -i HOME=/home/lfs TERM=\$TERM PS1='\u:\w\$ ' /bin/bash
```

  * *解释*：`env -i` 会清除所有继承的环境变量，只保留 HOME, TERM 和 PS1。这是为了“排毒”。

**`.bashrc` 内容：**

```bash
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/tools/bin:/bin:/usr/bin
export LFS LC_ALL LFS_TGT PATH
```

  * *解释*：
      * `set +h`：关闭 hash。强制 Shell 每次都重新搜索命令位置，而不是用缓存（防止我们刚装了新软件，Shell 还在用旧路径）。
      * `umask 022`：确保新创建的文件只有拥有者可写，其他人可读（标准的 755/644 权限）。

<!-- end list -->

4.  **验证环节**：
      * 脚本最后，输出提示：“用户创建成功。请运行 `su - lfs` 切换身份进行验证。”

**这个脚本将是我们作为 Root 身份运行的最后一个脚本。之后的操作，我们将变身为 `lfs` 用户。请开始编写！**

### ✅ 验证环节 (Unit Test)

在进入下一章之前，我们必须进行一次\*\*“穿越测试”\*\*。如果这一步失败了，后面的编译全是徒劳。

请执行以下操作（在你的终端里）：

1.  **运行你的脚本**：`sudo ./setup_lfs_user.sh`
2.  **穿越身份**：`su - lfs`
      * *注意：中间的 `-` 号至关重要！它表示“登录式 Shell”，只有加了它，Linux 才会去读取 `.bash_profile` 和 `.bashrc`。*
3.  **检查环境**：
    输入 `env` 命令，查看输出。
      * **检查 `LFS`**：是否显示 `/mnt/lfs`？
      * **检查 `LFS_TGT`**：是否显示类似 `x86_64-lfs-linux-gnu`？
      * **检查 `PATH`**：**重中之重！** `/tools/bin` 必须排在第一个！

**如果你看到 `lfs` 用户下的 `env` 输出正常，那么恭喜你，准备工作彻底完成！** 🚪🗝️