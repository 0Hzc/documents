### 🏛️ 第四课：隔离的艺术 —— LFS 用户与环境配置

在开始写代码之前，我们需要解决一个严肃的问题：**为什么我们不能用 Root 身份去编译？**

#### 1\. 为什么必须创建 `lfs` 用户？

你现在是 WSL 的 `root` 用户（通过 `sudo`）。如果你直接开始编译 GCC 或 Binutils，会有两个巨大风险：

1.  **毁灭宿主的风险**：如果你手滑（比如在 Makefile 里写错了一行 `rm -rf /`），你的 WSL 系统就废了。
2.  **“污染”风险（最关键）**：
      * Root 用户有很多环境变量（`PATH`, `LD_LIBRARY_PATH` 等），指向宿主机的 `/usr/include` 或 `/usr/lib`。
      * 如果在编译时，新的 GCC 偷偷引用了宿主机的库文件，编译可能也会成功。
      * **但是**，当你把做好的 LFS 放到另一台机器上运行时，它会因为找不到原来的宿主文件而报错。这叫“不纯净的构建”。

因此，我们需要创建一个**一穷二白**的新用户——`lfs`。

  * 它没有复杂的环境变量。
  * 它的权限被严格限制。
  * 我们通过编写它的 `.bashrc`，**强行**指定它只能看哪里，不能看哪里。

#### 2\. 关键环境变量解密

我们需要给 `lfs` 用户配置几个雷打不动的变量：

  * **`LFS=/mnt/lfs`**：告诉它工作目录在哪。
  * **`LC_ALL=POSIX`**：
      * 这是为了防止“语言不通”。
      * 如果你用中文环境编译，`grep` 或 `sed` 可能会因为无法识别某些字符而报错，或者按照中文排序规则处理文件列表，导致编译顺序出错。`POSIX` 是计算机最原始的语言环境。
  * **`LFS_TGT=$(uname -m)-lfs-linux-gnu`**：
      * 这是**交叉编译**的核心。
      * 我们在宿主机上，要编译一个给未来 LFS 系统用的工具。我们必须明确告诉编译器：“我是 x86\_64 架构，我是专门为 LFS 打造的 Linux GNU 系统”。
  * **`PATH=/tools/bin:/bin:/usr/bin`**：
      * **注意顺序！** `/tools/bin` 放在最前面。
      * 这意味着：如果我们编译出了一个新的 `gcc` 并放在了 `/tools/bin` 下，系统会**优先使用**这个新的 gcc，而不是宿主机的 `/usr/bin/gcc`。这就是“自举”的开始。

-----

### 🛠️ 任务四：创建构建用户与环境配置文件

请编写脚本 `setup_lfs_user.sh`。这个脚本依然需要 `sudo` 运行，因为它涉及创建用户。

**我负责提供配置文件内容，你负责实现自动化逻辑：**

**脚本需求：**

1.  **创建组和用户**：

      * 创建组 `lfs`。
      * 创建用户 `lfs`，属于 `lfs` 组。
      * 参数建议：`useradd -s /bin/bash -g lfs -m -k /dev/null lfs`
      * *解释*：`-k /dev/null` 表示不复制系统的默认骨架文件，我们要一个**绝对干净**的家目录。
      * **设置密码**：脚本里可以使用 `echo "lfs:123456" | chpasswd` 来自动设置密码（或者你手动设）。

2.  **移交目录权限**：

      * 我们在第二课创建了 `/tools` 软链接和 `/mnt/lfs/tools` 目录。
      * 现在，必须把这两个地方的所有权（Owner）交给 `lfs` 用户，否则它没法往里面装软件。
      * 命令：`chown -v lfs:lfs $LFS/tools` 和 `chown -v lfs:lfs $LFS/sources`。

3.  **生成配置文件 (核心)**：

      * 在 `/home/lfs` 目录下，生成 `.bash_profile` 和 `.bashrc`。
      * **注意**：因为你是用 root 运行脚本，生成文件的属主默认是 root。生成完后，记得把这俩文件的属主也改为 `lfs`。

**配置文件内容（请原样写入）：**

**`.bash_profile` 内容：**

```bash
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
```

  * *解释*：`env -i` 会清除所有继承的环境变量，只保留 HOME, TERM 和 PS1。这是为了“排毒”。

**`.bashrc` 内容：**

```bash
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/tools/bin:/bin:/usr/bin
export LFS LC_ALL LFS_TGT PATH
```

  * *解释*：
      * `set +h`：关闭 hash。强制 Shell 每次都重新搜索命令位置，而不是用缓存（防止我们刚装了新软件，Shell 还在用旧路径）。
      * `umask 022`：确保新创建的文件只有拥有者可写，其他人可读（标准的 755/644 权限）。

<!-- end list -->

4.  **验证环节**：
      * 脚本最后，输出提示：“用户创建成功。请运行 `su - lfs` 切换身份进行验证。”

**这个脚本将是我们作为 Root 身份运行的最后一个脚本。之后的操作，我们将变身为 `lfs` 用户。请开始编写！**